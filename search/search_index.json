{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"sensor-lora Home Assistant LoRa-connected sensor firmware for an ESP32. Version 0.1.0 OK. It's pretty niche. But if you happen to have, say, a greenhouse that is beyond packet-radio transmission distance for a battery powered temperature sensor, here's arduino firmware for an ESP32 providing Home Assistant sensor data over a LoRa link. Yes. You can now check your greenhouse temperature from 5 km away. Handy! Drivers for a VEM7700 light sensor , Sensirion SHT31 temperature and humidity sensor , and the device's battery voltage are provided. The firmware's plugin architecture makes it easily extensible to provide new sensors. License This project is licensed under the MIT License - see file LICENSE.md for details. Version history 0.1 Initial release.","title":"sensor-lora"},{"location":"index.html#sensor-lora","text":"Home Assistant LoRa-connected sensor firmware for an ESP32. Version 0.1.0 OK. It's pretty niche. But if you happen to have, say, a greenhouse that is beyond packet-radio transmission distance for a battery powered temperature sensor, here's arduino firmware for an ESP32 providing Home Assistant sensor data over a LoRa link. Yes. You can now check your greenhouse temperature from 5 km away. Handy! Drivers for a VEM7700 light sensor , Sensirion SHT31 temperature and humidity sensor , and the device's battery voltage are provided. The firmware's plugin architecture makes it easily extensible to provide new sensors.","title":"sensor-lora"},{"location":"index.html#license","text":"This project is licensed under the MIT License - see file LICENSE.md for details.","title":"License"},{"location":"index.html#version-history","text":"0.1 Initial release.","title":"Version history"},{"location":"LICENSE.html","text":"MIT License Copyright (c) 2022 Richard Lyon. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"firmware.html","text":"Firmware The firmware is developed as a platformio project. It uses the espressif32 platform and arduino framework. Configuration Configuration is done through compiler flags to limit the need to modify the firmware. I2C Define the SDA and SCL pins as: build_flags = -D PIN_SDA=21 -D PIN_SCL=22 Publish interval The publishing interval is defined as: build_flags = -D PUBLISH_INTERVAL_SECS=10 -D MODE_DEEP_SLEEP_MINS=0 Deep sleep has been investigated as a mechanism for extending battery life. At this revision, it doesn't work pending resolving an issue around waking up and reconnecting the LoRa radio. For now, set it to 0 minutes to disable the feature in firmware. Authentication credentials LoRa uses a The Things Netwotk (TTN) application (see LoRa for details). The firmware requires the app eui, dev ei, and app key to connect. To avoid exposing these authentication credentials in version control, they are obtained from a local file and provided as compiler flags. To configure, create a file named secret_auth_XXX.py in the same directory as platformio.ini . add them to this file in the following format: # TTN 'heltec lora environment sensor' credentials keys = { \"APP_EUI\": \"XXX\", \"DEV_EUI\": \"XXX\", \"APP_KEY\": \"XXX\", } print(f\"-D APP_EUI={keys['APP_EUI']} -D DEV_EUI={keys['DEV_EUI']} -D APP_KEY={keys['APP_KEY']} \") Finally, add the following buid flag specifier in platformio.ini : build_flags = !python secret_auth_XXX.py LoRa The firmware uses Francois Riotte's library TheThingsNetwork_esp32 . This requires a number of compiler definitions for specifying e.g. the LoRaWAN specification, region, etc. as described here . Check platformio.ini for actual variables, but these typically are: [env:ttgo-lora32-v21] build_flags = -D ARDUINO_LMIC_PROJECT_CONFIG_H_SUPPRESS -D CFG_eu868=1 -D CFG_sx1276_radio=1 -D LMIC_LORAWAN_SPEC_VERSION=LMIC_LORAWAN_SPEC_VERSION_1_0_3 Additional flags are required to specify the pins used for LoRa boards which are not pre-integrated (which the TTGO LoRa v21 is not). These are specified as follows: build_flags = -D NSS=18 -D RST=14 -D DIO0=26 -D DIO1=33 -D DIO2=32 This spreadsheet may help you identify the pins for your microcontroller. Code structure The code employs a simple plugin architecture to allow new devices to be added relatively easily. It defines a Sensor object representing the Lora driver object, and one or more Entity objects providing attributes (using the language of Home Assistant ). At setup, the lora and entities are registered and started. The runloop drives a timer for the publishing interval. If this isn't clear: an 'entity' is something like an SHT31 temperature and humidity sensor. 'Temperature' and 'humidity' are attributes of that sensor. protobuf The device employes Google's Protocol Buffers for serialising and transmitting data. This has the advantage of generating very efficient packets, which reduces power requirements and extends battery life. It has the disadvantage of being a pain to implement on microcontrollers. I've made it as simple as possible to extend. The schema is defined in /protobuf-packet/packet.proto . String sizes for any metadata must be defined in /protobuf-packet/packet.options . Together, these define a Packet data structure that can be processed be e.g. node-RED . If you alter this, you need to regenerate the header and implementation code in proto (don't alter these by hand) - see /protobuf-packet/README.md for instructions. The result of this is a set of constants you can use in your entity implementations to define entity and attribute properties -- look at an existing Entity implementationfor how to do it. Entity class This handles starting the entity, reading the data, and serialising it. Each entity object provides a start() method and a readData() method. start() returns true if startup and initialising was successful. readData() obtains the latest data from the sensor and serialises it for encoding by the LoRa class. Battery An entity class ( EntityBattery ) is defined for reporting the device battery voltage. This may require calibration on your battery as follows: build_flags = -D BATTERY_CORRECTION_FACTOR=0.885 I set it to one, measured the voltage and compared it to the reported value, then computed the correction factor. Lora class This handles starting the radio, joining The Things Network, serialising the readings from the sensors, and transmitting it. The device will hang during start() if it cannot join. publish() takes a vector of readings from the sensors, encodes it as a protocol buffer Packet , and transmits it. Sensor class This handles registering entities and the radio, starting them, reading their data at a defined interval, and sending the data to the LoRa for transmission. Add new entities like so: #include <EntityMyExcellentThing.h> EntityMyExcellentThing excellentThing; void setup() { ... sensor.registerEntity( &excellentThing ); }","title":"Firmware"},{"location":"firmware.html#firmware","text":"The firmware is developed as a platformio project. It uses the espressif32 platform and arduino framework.","title":"Firmware"},{"location":"firmware.html#configuration","text":"Configuration is done through compiler flags to limit the need to modify the firmware.","title":"Configuration"},{"location":"firmware.html#i2c","text":"Define the SDA and SCL pins as: build_flags = -D PIN_SDA=21 -D PIN_SCL=22","title":"I2C"},{"location":"firmware.html#publish-interval","text":"The publishing interval is defined as: build_flags = -D PUBLISH_INTERVAL_SECS=10 -D MODE_DEEP_SLEEP_MINS=0 Deep sleep has been investigated as a mechanism for extending battery life. At this revision, it doesn't work pending resolving an issue around waking up and reconnecting the LoRa radio. For now, set it to 0 minutes to disable the feature in firmware.","title":"Publish interval"},{"location":"firmware.html#authentication-credentials","text":"LoRa uses a The Things Netwotk (TTN) application (see LoRa for details). The firmware requires the app eui, dev ei, and app key to connect. To avoid exposing these authentication credentials in version control, they are obtained from a local file and provided as compiler flags. To configure, create a file named secret_auth_XXX.py in the same directory as platformio.ini . add them to this file in the following format: # TTN 'heltec lora environment sensor' credentials keys = { \"APP_EUI\": \"XXX\", \"DEV_EUI\": \"XXX\", \"APP_KEY\": \"XXX\", } print(f\"-D APP_EUI={keys['APP_EUI']} -D DEV_EUI={keys['DEV_EUI']} -D APP_KEY={keys['APP_KEY']} \") Finally, add the following buid flag specifier in platformio.ini : build_flags = !python secret_auth_XXX.py","title":"Authentication credentials"},{"location":"firmware.html#lora","text":"The firmware uses Francois Riotte's library TheThingsNetwork_esp32 . This requires a number of compiler definitions for specifying e.g. the LoRaWAN specification, region, etc. as described here . Check platformio.ini for actual variables, but these typically are: [env:ttgo-lora32-v21] build_flags = -D ARDUINO_LMIC_PROJECT_CONFIG_H_SUPPRESS -D CFG_eu868=1 -D CFG_sx1276_radio=1 -D LMIC_LORAWAN_SPEC_VERSION=LMIC_LORAWAN_SPEC_VERSION_1_0_3 Additional flags are required to specify the pins used for LoRa boards which are not pre-integrated (which the TTGO LoRa v21 is not). These are specified as follows: build_flags = -D NSS=18 -D RST=14 -D DIO0=26 -D DIO1=33 -D DIO2=32 This spreadsheet may help you identify the pins for your microcontroller.","title":"LoRa"},{"location":"firmware.html#code-structure","text":"The code employs a simple plugin architecture to allow new devices to be added relatively easily. It defines a Sensor object representing the Lora driver object, and one or more Entity objects providing attributes (using the language of Home Assistant ). At setup, the lora and entities are registered and started. The runloop drives a timer for the publishing interval. If this isn't clear: an 'entity' is something like an SHT31 temperature and humidity sensor. 'Temperature' and 'humidity' are attributes of that sensor.","title":"Code structure"},{"location":"firmware.html#protobuf","text":"The device employes Google's Protocol Buffers for serialising and transmitting data. This has the advantage of generating very efficient packets, which reduces power requirements and extends battery life. It has the disadvantage of being a pain to implement on microcontrollers. I've made it as simple as possible to extend. The schema is defined in /protobuf-packet/packet.proto . String sizes for any metadata must be defined in /protobuf-packet/packet.options . Together, these define a Packet data structure that can be processed be e.g. node-RED . If you alter this, you need to regenerate the header and implementation code in proto (don't alter these by hand) - see /protobuf-packet/README.md for instructions. The result of this is a set of constants you can use in your entity implementations to define entity and attribute properties -- look at an existing Entity implementationfor how to do it.","title":"protobuf"},{"location":"firmware.html#entity-class","text":"This handles starting the entity, reading the data, and serialising it. Each entity object provides a start() method and a readData() method. start() returns true if startup and initialising was successful. readData() obtains the latest data from the sensor and serialises it for encoding by the LoRa class.","title":"Entity class"},{"location":"firmware.html#battery","text":"An entity class ( EntityBattery ) is defined for reporting the device battery voltage. This may require calibration on your battery as follows: build_flags = -D BATTERY_CORRECTION_FACTOR=0.885 I set it to one, measured the voltage and compared it to the reported value, then computed the correction factor.","title":"Battery"},{"location":"firmware.html#lora-class","text":"This handles starting the radio, joining The Things Network, serialising the readings from the sensors, and transmitting it. The device will hang during start() if it cannot join. publish() takes a vector of readings from the sensors, encodes it as a protocol buffer Packet , and transmits it.","title":"Lora class"},{"location":"firmware.html#sensor-class","text":"This handles registering entities and the radio, starting them, reading their data at a defined interval, and sending the data to the LoRa for transmission. Add new entities like so: #include <EntityMyExcellentThing.h> EntityMyExcellentThing excellentThing; void setup() { ... sensor.registerEntity( &excellentThing ); }","title":"Sensor class"},{"location":"hardware.html","text":"Hardware Microcontroller The firmware has been developed and tested on a LILYGO T3 V2.1.6 LoRa32 microcontroller. Other boards can be targetted and I've successfully tested it with the Heltec WiFi LoRa 32(v2). Sensors The firmware recognises sensors connected to the I2C bus. LoRa The device communicates through any LoRaWAN gateway that is in range. This firmware has been tested using a Laird Sentrius RG186 .","title":"Harware"},{"location":"hardware.html#hardware","text":"","title":"Hardware"},{"location":"hardware.html#microcontroller","text":"The firmware has been developed and tested on a LILYGO T3 V2.1.6 LoRa32 microcontroller. Other boards can be targetted and I've successfully tested it with the Heltec WiFi LoRa 32(v2).","title":"Microcontroller"},{"location":"hardware.html#sensors","text":"The firmware recognises sensors connected to the I2C bus.","title":"Sensors"},{"location":"hardware.html#lora","text":"The device communicates through any LoRaWAN gateway that is in range. This firmware has been tested using a Laird Sentrius RG186 .","title":"LoRa"},{"location":"lora.html","text":"LoRa You'll need to create an application on The Things Network and obtain keys for it. See The Things Network ' Add an Application ' for details.","title":"LoRa"},{"location":"lora.html#lora","text":"You'll need to create an application on The Things Network and obtain keys for it. See The Things Network ' Add an Application ' for details.","title":"LoRa"},{"location":"nodered.html","text":"Node-RED To get the data into Home Assistant, a Node-RED flow is provided that decodes the protocol buffer Packet and transmits its content as a set of MQTT topics. The flow is defined in lib/node-red/lora-sensor.json , which you can import in your local instance of Noe-RED. For security reaons, I've omitted the MQTT in/out nodes because they require passwords. It expects a protocol definition schema in data/protobuf/packet.proto in your Node-RED folder. This is provided in lib/protobuf-packet/packet.proto . Data in / out The Things Network retransmits the protocal buffer packet emitted by the firmware over MQTT. Configure a Node-RED MQTT in node as follows and wire it to the inputs of the data and ttnMetadata nodes. connection server: eu1.cloud.thethings.network port: 1883 protocol: MQTT V3.1.1 session: use clean session security username: (whatever you defined for your The Things Network application) password: (whatever you defined for your The Things Network application) properties: server: (the one you defined in connection) action: subscribe to a single topic topic: v3/XXX@ttn/devices/YYY/up where XXX = your application name, YYY = the eui of your device in the application output: a parsed JSON object Configure a Node-RED MQTT out node to point to your Home Assistant MQTT server and hook it up to the outputs of the transfer topic and state nodes. What's going on The flow is using Home Assistant's MQTT Discovery feature to automate configuration of the device. It dynamically generates discovery and state topics from the packet, requiring no additional configuration other than provision of the protocol definition schema. In the Node-RED flow, the configuration node generates the discovery topics for each entity attribute present in Packet . Node state transmits each packet as it arrives on its defined MQTT topic, with attribute data as the payload. Home Assistant entity ID and Friendly Name are generated from the DEVICE_NAME build flag and protocol buffer EntityName and Attribute fields. A build flag sets the name of the sensor as it appears in Home Assistant (see firmware ): build_flags = -D DEVICE_NAME=greenhouse The entity and attribute names are as they are defined in the Protocol Buffer schema. So an attribute from a device with DEVICE_NAME \"greenhouse\", protocol buffer EntityName \"SHT31\" and protocol buffer Attribute \"temperature\" will appear with Home Assistant Entity ID as sensor.greenhouse_temperature_sht31 and friendly name Greenhouse temperature (SHT31) .","title":"Node-RED"},{"location":"nodered.html#node-red","text":"To get the data into Home Assistant, a Node-RED flow is provided that decodes the protocol buffer Packet and transmits its content as a set of MQTT topics. The flow is defined in lib/node-red/lora-sensor.json , which you can import in your local instance of Noe-RED. For security reaons, I've omitted the MQTT in/out nodes because they require passwords. It expects a protocol definition schema in data/protobuf/packet.proto in your Node-RED folder. This is provided in lib/protobuf-packet/packet.proto .","title":"Node-RED"},{"location":"nodered.html#data-in-out","text":"The Things Network retransmits the protocal buffer packet emitted by the firmware over MQTT. Configure a Node-RED MQTT in node as follows and wire it to the inputs of the data and ttnMetadata nodes. connection server: eu1.cloud.thethings.network port: 1883 protocol: MQTT V3.1.1 session: use clean session security username: (whatever you defined for your The Things Network application) password: (whatever you defined for your The Things Network application) properties: server: (the one you defined in connection) action: subscribe to a single topic topic: v3/XXX@ttn/devices/YYY/up where XXX = your application name, YYY = the eui of your device in the application output: a parsed JSON object Configure a Node-RED MQTT out node to point to your Home Assistant MQTT server and hook it up to the outputs of the transfer topic and state nodes.","title":"Data in / out"},{"location":"nodered.html#whats-going-on","text":"The flow is using Home Assistant's MQTT Discovery feature to automate configuration of the device. It dynamically generates discovery and state topics from the packet, requiring no additional configuration other than provision of the protocol definition schema. In the Node-RED flow, the configuration node generates the discovery topics for each entity attribute present in Packet . Node state transmits each packet as it arrives on its defined MQTT topic, with attribute data as the payload. Home Assistant entity ID and Friendly Name are generated from the DEVICE_NAME build flag and protocol buffer EntityName and Attribute fields. A build flag sets the name of the sensor as it appears in Home Assistant (see firmware ): build_flags = -D DEVICE_NAME=greenhouse The entity and attribute names are as they are defined in the Protocol Buffer schema. So an attribute from a device with DEVICE_NAME \"greenhouse\", protocol buffer EntityName \"SHT31\" and protocol buffer Attribute \"temperature\" will appear with Home Assistant Entity ID as sensor.greenhouse_temperature_sht31 and friendly name Greenhouse temperature (SHT31) .","title":"What's going on"}]}